{"pages":[],"posts":[{"title":"Java常用工具类","text":"字符串相关工具类Java 中 String 应该是日常用的最多一个类吧，平常我们很多代码需要围绕 String ，做一些处理。 JDK 提供 String API 虽然比较多，但是功能比较基础，通常我们需要结合 String 多个方法才能完成一个业务功能。 下面介绍一下 Apache 提供的一个工具类 StringUtils. Maven Pom 信息如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.10&lt;/version&gt;&lt;/dependency&gt; commons-lang 有两个版本，一个是 commons-lang3 ，一个是 commons-lang 。 commons-lang 是老版本，已经很久没有维护了。 commons-lang3 是一直在维护的版本，推荐直接使用这个版本。 注意：如果你系统已经有 commons-lang，注意如果直接替换成 commons-lang3，将会编译错误。commons-lang3 中相关类与 commons-lang 一样，但是包名不一样。 判断字符串是否为空判断字符串是否为空，想必每个人应该都写过吧： 123if(null == str || str.isEmpty()) {} 使用 StringUtils ，上面代码可以替换下面这样： 123if(StringUtils.isEmpty(str)) {} StringUtils 内部还有一个方法 isBlank，也是用来判断字符串是否为空，两个方法比较相近，比较搞混，主要区别如下： 123// 如果字符串是空格StringUtils.isBlank(&quot; &quot;); trueStringUtils.isEmpty(&quot; &quot;); false 字符串固定长度这个通常用于字符串需要固定长度的场景，比如需要固定长度字符串作为流水号，若流水号长度不足，，左边补 0 。 12// 字符串固定长度8位，若不足，往左补0StringUtils.leftPad(&quot;test&quot;,8,&quot;0&quot;); 另外还有一个StringUtils.rightPad()，与上面的方法相反 字符串关键字替换StringUtils 提供的一些方法，可以替换某些关键字： 123456// 默认替换所有关键字StringUtils.replace(&quot;aba&quot;,&quot;a&quot;,&quot;z&quot;); &quot;zbz&quot;// 仅替换一次StringUtils.replaceOnce(&quot;aba&quot;,&quot;a&quot;,&quot;z&quot;); &quot;zba&quot;// 使用正则表达式替换StringUtils.replacePattern(&quot;ABCabc123&quot;,&quot;[^A-Z0-9]+&quot;,&quot;&quot;); &quot;ABC123&quot; 字符串拼接字符串拼接是个常见的需求，使用 StringBuilder 循环遍历拼接： 1234567891011String[] array = new String[]{&quot;test&quot;, &quot;1234&quot;, &quot;5678&quot;};StringBuilder stringBuilder = new StringBuilder();for (String s : array) { stringBuilder.append(s).append(&quot;;&quot;);}// 防止最终拼接字符串为空 if (stringBuilder.length() &gt; 0) { stringBuilder.deleteCharAt(stringBuilder.length() - 1);}System.out.println(stringBuilder.toString()); 上面业务代码不太难，但是需要注意一下上面这段代码非常容易出错，容易抛出 StringIndexOutOfBoundsException。 这里我们可以直接使用以下方法获取拼接之后字符串： 1StringUtils.join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],&quot;,&quot;); &quot;a,b,c&quot; StringUtils 只能传入数组拼接字符串，不过我比较喜欢集合拼接，所以再推荐下 Guava 的 Joiner。 实例代码如下： 1234567891011String[] array = new String[]{&quot;test&quot;, &quot;1234&quot;, &quot;5678&quot;};List&lt;String&gt; list=new ArrayList&lt;&gt;();list.add(&quot;test&quot;);list.add(&quot;1234&quot;);list.add(&quot;5678&quot;);StringUtils.join(array, &quot;,&quot;);// 逗号分隔符，跳过 nullJoiner joiner=Joiner.on(&quot;,&quot;).skipNulls();joiner.join(array);joiner.join(list); 字符串拆分有字符串拼接，就会有拆分字符串的需求，同样的 StringUtils 也有拆分字符串的方法。 12StringUtils.split(&quot;a..b.c&quot;, '.') = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;a..b.c&quot;, &quot;.&quot;)= [&quot;a&quot;,&quot;&quot;, &quot;b&quot;, &quot;c&quot;] ps:注意以上两个方法区别。 StringUtils 拆分之后得到是一个数组，我们可以使用 Guava 的 12345Splitter splitter = Splitter.on(&quot;,&quot;);// 返回是一个 List 集合，结果：[ab, , b, c]splitter.splitToList(&quot;ab,,b,c&quot;);// 忽略空字符串，输出结果 [ab, b, c]splitter.omitEmptyStrings().splitToList(&quot;ab,,b,c&quot;) StringUtils 内部还有其他常用的方法，小伙伴们可以自行查看其 API。 日期相关工具类DateUtils/DateFormatUtilsJDK8 之前，Java 只提供一个 Date 类，平常我们需要将 Date 按照一定格式转化成字符串，我们需要使用 SimpleDateFormat。 12345SimpleDateFormat simpleDateFormat=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// Date 转 字符串simpleDateFormat.format(new Date());// 字符串 转 DatesimpleDateFormat.parse(&quot;2020-05-07 22:00:00&quot;); 代码虽然简单，但是这里需要注意 SimpleDateFormat，不是线程安全的，多线程环境一定要注意使用安全。 这里小黑哥推荐 commons-lang3 下的时间工具类DateUtils/DateFormatUtils,解决 Date 与字符串转化问题。使用方法非常简单： 1234// Date 转化为字符串DateFormatUtils.format(new Date(),&quot;yyyy-MM-dd HH:mm:ss&quot;);// 字符串 转 DateDateUtils.parseDate(&quot;2020-05-07 22:00:00&quot;,&quot;yyyy-MM-dd HH:mm:ss&quot;); 除了格式转化之外，DateUtils 还提供时间计算的相关功能。 123456789101112Date now = new Date();// Date 加 1 天Date addDays = DateUtils.addDays(now, 1);// Date 加 33 分钟Date addMinutes = DateUtils.addMinutes(now, 33);// Date 减去 233 秒Date addSeconds = DateUtils.addSeconds(now, -233);// 判断是否 Wie 同一天boolean sameDay = DateUtils.isSameDay(addDays, addMinutes);// 过滤时分秒,若 now 为 2020-05-07 22:13:00 调用 truncate 方法以后// 返回时间为 2020-05-07 00:00:00Date truncate = DateUtils.truncate(now, Calendar.DATE); JDK8 时间类JDK8 之后，Java 将日期与时间分为 LocalDate，LocalTime，功能定义更加清晰，当然其也提供一个 LocalDateTime，包含日期与时间。这些类相对于 Date 类优点在于，这些类与 String 类一样都是不变类型，不但线程安全，而且不能修改。 现在 mybatis 等 ORM 框架已经支持 LocalDate 与 JDBC 时间类型转化，所以大家可以直接将时间字段实际类型定义为 JDK8 时间类型，然后再进行相关转化。 如果依然使用的是 Date 类型，如果需要使用新的时间类型，我们需要进行相关转化。两者之间进行转化， 稍微复杂一点，我们需要显示指定当前时区。 12345Date now = new Date();// Date-----&gt; LocalDateTime 这里指定使用当前系统默认时区LocalDateTime localDateTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();// LocalDateTime------&gt; Date 这里指定使用当前系统默认时区Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); 接下来我们使用 LocalDateTime 进行字符串格式化。 1234// 按照 yyyy-MM-dd HH:mm:ss 转化时间LocalDateTime dateTime = LocalDateTime.parse(&quot;2020-05-07 22:34:00&quot;, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));// 将 LocalDateTime 格式化字符串String format = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(dateTime); 另外我们使用 LocalDateTime 获取当前时间年份，月份特别简单： 1234567LocalDateTime now = LocalDateTime.now();// 年int year = now.getYear();// 月int month = now.getMonthValue();// 日int day = now.getDayOfMonth(); 最后我们还可以使用 LocalDateTime 进行日期加减，获取下一天的时间： 123456LocalDateTime now = LocalDateTime.now();// 当前时间加一天LocalDateTime plusDays = now.plusDays(1l);// 当前时间减一个小时LocalDateTime minusHours = now.minusHours(1l);// 还有很多其他方法 集合/数组相关集合与数组我们日常也需要经常使用，也需要对其进行判空： 123if (null == list || list.isEmpty()) {} 上面代码如字符串判空一样写起来都非常简单，但是也比较容易写出会抛出空指针异常的代码。这里我们可以使用 commons-collections 提供工具类。 pom 信息： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.4&lt;/vesion&gt;&lt;/dependency&gt; ps: 还有一个低版本的 ，artifactId 为 commons-collections 我们可以使用 CollectionUtils/MapUtils进行判空判断。 12345678// List/Set 集合判空if(CollectionUtils.isEmpty(list)){}// Map 等集合进行判空if (MapUtils.isEmpty(map)) { } 至于数组判空判断需要使用 commons-lang 下的 ArrayUtils进行判断: 1234// 数组判空if (ArrayUtils.isEmpty(array)) { } 除此之外还有一些列的对于集合增强方法，比如快速将数组加入到现有集合中： 123456List&lt;String&gt; listA = new ArrayList&lt;&gt;();listA.add(&quot;1&quot;);listA.add(&quot;2&quot;);listA.add(&quot;3&quot;);String[] arrays = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};CollectionUtils.addAll(listA, arrays); 其他方法感兴趣同学可以再自行研究下，另外 Guava 中也有提供对于集合的操作增强类 Lists/Maps I/O 相关JDK 有提供一系列的类可以读取文件等，不过小黑哥觉得那些类有些晦涩难懂，实现一个小功能可能还要写好多代码，而且还不一定能写对。 推荐一下 Apache 提供的 commons-io 库，增强 I/O 操作，简化操作难度。pom 信息： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; FileUtils-文件操作工具类文件操作工具类提供一系列方法，可以让我们快速读取写入文件。 快速实现文件/文件夹拷贝操作 ,FileUtils.copyDirectory/FileUtils.copyFile 1234// 拷贝文件File fileA = new File(&quot;E:\\\\test\\\\test.txt&quot;);File fileB = new File(&quot;E:\\\\test1\\\\test.txt&quot;);FileUtils.copyFile(fileA,fileB); 使用 FileUtils.listFiles 获取指定文件夹上所有文件 123// 按照指定文件后缀如java,txt等去查找指定文件夹的文件File directory = new File(&quot;E:\\\\test&quot;);FileUtils.listFiles(directory, new String[]{&quot;txt&quot;}, false); 使用 FileUtils.readLines 读取该文件所有行。 12// 读取指定文件所有行 不需要使用 while 循环读取流了List&lt;String&gt; lines = FileUtils.readLines(fileA) 有读就存在写，可以使用 FileUtils.writeLines，直接将集合中数据，一行行写入文本。 1234// 可以一行行写入文本List&lt;String&gt; lines = new ArrayList&lt;&gt;();.....FileUtils.writeLines(lines) IOUtils-I/O 操作相关工具类FileUtils 主要针对相关文件操作，IOUtils 更加针对底层 I/O,可以快速读取 InputStream。实际上 FileUtils 底层操作依赖就是 IOUtils。 IOUtils可以适用于一个比较试用的场景，比如支付场景下，HTTP 异步通知场景。如果我们使用 JDK 原生方法写: 从 Servlet 获取异步通知内容 1234567891011121314151617181920212223242526byte[] b = null;ByteArrayOutputStream baos = null;String respMsg = null;try { byte[] buffer = new byte[1024]; baos = new ByteArrayOutputStream(); // 获取输入流 InputStream in = request.getInputStream(); for (int len = 0; (len = in.read(buffer)) &gt; 0; ) { baos.write(buffer, 0, len); } b = baos.toByteArray(); baos.close(); // 字节数组转化成字符串 String reqMessage = new String(b, &quot;utf-8&quot;);} catch (IOException e) { } finally { if (baos != null) { try { baos.close(); } catch (IOException e) { } }} 上面代码说起来还是挺复杂的。不过我们使用 IOUtils，一个方法就可以简单搞定： 1234// 将输入流信息全部输出到字节数组中byte[] b = IOUtils.toByteArray(request.getInputStream());// 将输入流信息转化为字符串String resMsg = IOUtils.toString(request.getInputStream()); ps: InputStream 不能被重复读取 计时编程中有时需要统计代码的的执行耗时，当然执行代码非常简单，结束时间与开始时间相减即可。 1234567long start = System.currentTimeMillis(); //获取开始时间//其他代码//...long end = System.currentTimeMillis(); //获取结束时间System.out.println(&quot;程序运行时间： &quot; + (end - start) + &quot;ms&quot;); 虽然代码很简单，但是非常不灵活，默认情况我们只能获取 ms 单位，如果需要转换为秒，分钟，就需要另外再计算。 这里我们介绍 Guava Stopwatch 计时工具类，借助他统计程序执行时间，使用方式非常灵活。 commons-lang3 与 Spring-core 也有这个工具类，使用方式大同小异，大家根据情况选择。 123456789101112131415161718192021// 创建之后立刻计时，若想主动开始计时Stopwatch stopwatch = Stopwatch.createStarted();// 创建计时器，但是需要主动调用 start 方法开始计时// Stopwatch stopwatch = Stopwatch.createUnstarted();// stopWatch.start();// 模拟其他代码耗时TimeUnit.SECONDS.sleep(2L);// 当前已经消耗的时间System.out.println(stopwatch.elapsed(TimeUnit.SECONDS));;TimeUnit.SECONDS.sleep(2L);// 停止计时 未开始的计时器调用 stop 将会抛错 IllegalStateExceptionstopwatch.stop();// 再次统计总耗时System.out.println(stopwatch.elapsed(TimeUnit.SECONDS));;// 重新开始，将会在原来时间基础计算，若想重新从 0开始计算，需要调用 stopwatch.reset()stopwatch.start();TimeUnit.SECONDS.sleep(2L);System.out.println(stopwatch.elapsed(TimeUnit.SECONDS)); 输出结果为： 123246 作者：楼下小黑哥链接：https://juejin.im/post/5eba01ef5188256d85793593","link":"/2020/05/15/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"测试","text":"一级标题二级标题的发射点的风格 123dgdlfgjdfg lsdlg 发生的 f都是 功夫 更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好 机构行家 g hjk fj g ghj ghj更好","link":"/2020/05/19/%E6%B5%8B%E8%AF%95/"},{"title":"Linux卸载Mysql","text":"","link":"/2020/05/26/Linux%E5%8D%B8%E8%BD%BDMysql/"}],"tags":[{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"标签1","slug":"标签1","link":"/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","link":"/tags/%E6%A0%87%E7%AD%BE2/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"标签类","slug":"标签类","link":"/categories/%E6%A0%87%E7%AD%BE%E7%B1%BB/"}]}